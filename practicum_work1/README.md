# Практическая работа "Сравнение скорости работы динамического массива и односвязного списка"

## Введение
Данная практическая работа посвящена сравнению скорости работы двух структур данных: динамического массива и односвязного списка. Задача заключалась в реализации двух стеков на этих структурах и проведении серии тестов для оценки их производительности.

## Реализация
Для выполнения работы были реализованы две структуры данных: динамический массив и односвязный список. Каждая структура была использована для реализации соответствующего стека.

Стек на динамическом массиве обладает быстрым доступом к элементам по индексу и экономичным использованием памяти.
Стек на односвязном списке обеспечивает гибкость и возможность изменения размера стека во время выполнения программы.

Каждый из стеков имеет следующие функции:
- stack_ctr(size_t size, size_t element_size) - создание стека заданного размера и размера элемента
- push(struct Stack* st, void* buffer) - добавление элемента в стек
- top(struct Stack* st, void* buffer) - получение последнего элемента стека
- pop(struct Stack* st) - удаление последнего элемента стека
- stack_dtr(struct Stack* st) - уничтожение стека, освобождение памяти

## Тесты и результаты
Для оценки производительности стеков были проведены следующие тесты:

### Тест 1
- Заполнение стека 10^6 элементами
- Удаление половины элементов и добавление четверти
- Повторение удаления половины и добавления четверти, пока в стеке не останется менее 100000 элементов
Результаты:
- Стек на динамическом массиве: 0.031667 сек
- Стек на односвязном списке: 0.278667 сек

### Тест 2
- Заполнение стека 10^6 элементами
- 100 итераций удаления 10000 элементов и добавления столько же
- Повторение теста 1
Результаты:
- Стек на динамическом массиве: 0.015333 сек
- Стек на односвязном списке: 0.167667 сек

### Тест 3
- Добавление случайных чисел из множества {1, 2} в стек размером 1 миллион элементов
- Выполнение 1 миллиона инструкций, добавляющих элементы и извлекающих элементы из стека
- Замер времени после достижения размера стека в 1 миллион элементов
Результаты:
- Стек на динамическом массиве: 0.015667 сек
- Стек на односвязном списке: 0.041667 сек

Для динамического массива:
   ![резы тестов](./practicum_work1/Pictures/tests2.png)
Для односвязного списка:
   ![резы тестов](./practicum_work1/Pictures/tests1.png)
### Тест 4
- Построение графика зависимости времени выполнения от количества вставок для стека на массиве. Количество вставок итерируется с шагом 1000 от 1000 до 10^6.
   ![резы тестов](./practicum_work1/Pictures/StackGraphs.png)
## Вывод
По результатам проведенных тестов и сравнения скорости работы стеков на динамическом массиве и односвязном списке можно сделать следующие выводы.

После проведения тестов и сравнения результатов можно сделать следующие выводы.
Стек на динамическом массиве:
- быстрый доступ к элементам стека
- элементы в динамическом массиве хранятся последовательно, что обеспечивает эффективное использование кэш-памяти процессора. Это может привести к улучшению производительности, поскольку процессор может загрузить блоки памяти сразу нескольких элементов, что уменьшает задержку и время выполнения операций.
- экономия памяти, так как стек на массиве занимает меньшее количество памяти, чем стек на односвязном списке
Стек на односвязном списке:
- гибкость и возможность изменения динамического размера стека
Таким образом, стек динамическом массиве работает быстрее
