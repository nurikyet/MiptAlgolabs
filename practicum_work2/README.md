# Практическая работа "Сравнение скорости работы различных видов сортировок"

## Введение
Данная лабараторная работа предполагает сравнение различных видов сортировок, а также попытку потягаться с библиотечной функцией qsort.

## Тесты и результаты
Для оценки производительности скорости сортировок были проведенен один из следующих тестов:

### Тест 1
- very_small_tests -- тесты с массивами размера от 1 до 150 с шагом 1, ограничение MAX_RAND, тестов каждого размера 5

### Тест 2
- small_tests -- тесты с массивами размера от 0 до 1000 с шагом 50, ограничение MAX_RAND, тестов каждого размера 5

### Тест 3
- big_tests (тесты от 0 до 1000000 с шагом 10000, ограничение MAX_RAND)

### Тест 4
- test_most_dublicates (тесты от 0 до 1000000 с шагом 10000, ограничение значения элемента 10000) 

## Пункт 1. Квадратичные (и не совсем) сортировки
### Реализация
- Сортировка вставками: Пошагово вставляет элементы в отсортированную часть массива.
- Сортировка пузырьком: Постепенно сдвигает наибольший элемент к концу массива.
- Сортировка выбором: Выбирает минимальный элемент и ставит его на начало неотсортированной части массива.
- Сортировка Шелла: Улучшенная версия сортировки вставками, использующая последовательность Шелла, предложенную Дональдом Кнутом.
### Тестирование 
- Тестирование производилось на наборе массивов small_tests
### График 
![резы тестов](./practicum_work2/results/1_results/n^2_sort.png)

### Какая в сортировка в итоге отработала лучше всех?
Таким образом, сортировка Шелла является наиюолее эффективной, так как она является усовершенстванной версией сортировки вставками, 
она использует идею "разделяй и властвуй".  В отличие от сортировки вставками, где каждый элемент сравнивается и перемещается только на одну позицию влево или вправо, сортировка Шелла сравнивает и перемещает элементы на значительно более удаленные позиции. Сортировка пузырьком и сортировка выбором работают медленнее, потому что они имеют более высокую сложность. Обе эти сортировки требует множества swap-ов элементами.

## Пункт 2. Квадратичные (и не совсем) сортировки
### Реализация
Пирамидальную сортировка, основанная на k-ичной куче (k -- число детей кучи). 
### Тестирование 
- Тестирование производилось на наборе массивов big_tests
### График 
![резы тестов](./practicum_work2/results/2_results/heap_sort.png)
![резы тестов](./practicum_work2/results/2_results/heap_sort2.png)
###  Какое k оказалось оптимальным?
Наиболее быстрым оказалось, ранвое 8. HeapSort на k-ичной куче работает за O(n log n) в среднем и в худшем случае. Данная сортировка является устойчивой, но не является адаптивной. Также она не является стабильной, поскольку не сохраняет относительный порядок равных элементов.

## Вывод
По результатам проведенных тестов и сравнения скорости работы стеков на динамическом массиве и односвязном списке можно сделать следующие выводы.

После проведения тестов и сравнения результатов можно сделать следующие выводы.
Стек на динамическом массиве:
- быстрый доступ к элементам стека
- элементы в динамическом массиве хранятся последовательно, что обеспечивает эффективное использование кэш-памяти процессора. Это может привести к улучшению производительности, поскольку процессор может загрузить блоки памяти сразу нескольких элементов, что уменьшает задержку и время выполнения операций.
- экономия памяти, так как стек на массиве занимает меньшее количество памяти, чем стек на односвязном списке
Стек на односвязном списке:
- гибкость и возможность изменения динамического размера стека
Таким образом, стек динамическом массиве работает быстрее