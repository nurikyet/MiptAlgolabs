# Исследование Хэш-Функций

### Реализация 
Генерация 1000000 случайных ключей, и построение столбчатой диаграммы коллизий для хэш-функции.

### Для int-ов 
1. Остаток от деления
постороение хэш-функции методом деления с остатком состоит в том, что ключу k ставится в соответствие остаток от деления на m,
где m - число возможных хэш-функций

$h(k) = k \mod m$

---
   ![остаток от деления](./int/result/division.png)
---

2. Битовое представление
построение хэш-функции методом битового представления состоит в том, что мы берем битовое представление числа и используем,
как 
---
   ![битовое представление](./int/result/bit.png)
---

3. Метод умножения с константой
---
   ![метод умножения с константой](./int/result/multi.png)
---

Пусть кол-тво хэш-значений m, то 

$h(k) = [m(kA \mod 1)]$, где $(kA \mod 1)$ - дробная часть kA.

### Результаты тестов

| хэш-функция        | время работы   | 
| ------------------ | -------------- | 
| остаток от деления |  0.496031 сек  | 
| битовое            |  0.559381 сек  |  
| метод умножения    |  0.497769 сек  |  

### Вывод
Таким образом, наиболее эффективная хэш-функция методом умножения, так как она минимизирует шансы попадания близких в
некотором смысле идентификаторов в одну ячейку
хеш-таблицы. Хэш-функция взятия остатка не всегда бывает эффективной, так как для нее существую 
«Плохие» значения m:
1. Вида $2^p$, где $p \in \N$
2. Вида $2^p – 1$, где $p \in \N$
   
Хэш-функция при помощи битового представления не эффективна,так как она заполняет только определенные ячейки, а некоторые вообще не затрагивает.

### Для float-ов

1. Преобразование к (int) c последующим взятием битого представления инта
   
построение хэш-функции методом взятия целой части и приведения ее битового представления

---
   ![преобразование к (int)](./float/result/to_int.png)
---

2. Битовое представление

построение хэш-функции взятием битового представления числа 

---
   ![битовое представление](./float/result/bits.png)
---

3. Извлечение мантиссы

Построение хэш-функции при помощи извлечения мантиссы числа

---
   ![извлечение мантиссы](./float/result/mantissa.png)
---

4. Извлечение экспоненты

Построение хэш-функции при помощи извлечения экспоненты числа

---
   ![извлечение экспоненты](./float/result/exponent.png)
---

5. Произведение мантиссы на экспоненту. 

Построение хэш-функции при помощи перемножения экспоненты и мантиссы числа

---
   ![произведение мантиссы на экспоненту](./float/result/multi.png)
---

### Результаты тестов

| хэш-функция                          | время работы   | 
| ------------------------------------ | -------------- | 
| преобразование к (int)               |  0.503996 сек  | 
| битовое представление                |  0.607860 сек  |  
| извлечение мантиссы                  |  0.502612 сек  |  
| извлечение экспоненты                |  0.501774 сек  |  
| прооизведение мантиссы на экспоненту |  0.508188 сек  |  

### Вывод
Одинаково эффективными являются хэш-функции, такие как битовое представление, преобразование к (int) c последующим взятием битого представления инта и извлечение мантиссы. Наиболее неэффективной хэш-функцией является взятие экспоненты, так как для чисел в диапозоне $[-10; 10]$ она может принимать только ограниченнное количество значений, также поэтому хэш-функция произведение мантиссы на экспоненту менее эффективна.

### Для строк

1. Длинна строки

Построение хэш-функции при помощи взятия длины строки

---
   ![длинна строки](./line/result/line_len.png)
---

2. Сумма букв

Построение хэш-функции при помощи взятия суммы букв в строке

---
   ![сумма букв](./line/result/sum_letters.png)
---

Откуда возникают шляпки?

Длина слова от $5$ до $20$, при этом каждая буква принимает занчение от $97$ до $122$. 
Так для слова длины $5$ значения могут принимать от $5*97 = 485$ до $5*122 = 610$, при этом крайние значения получаются меньшим количеством способов, например $485$ 
можно получить только сочетанием "aaaaa", $486$ сочетанием "aaaab", "aaaba". "aabaa", "abaaa", "baaaa".
в то время как центральные значения можено получить большим количеством комбинаций, и так для слов длины от $5$ до $20$.
Если взять большое количество случайных строк и применить к ним хэш-функцию суммы букв, то распределение полученных хэш-значений будет приближаться к нормальному распределению, т е к нормальному распределению Ирвина.

3. Полиномиальный

Пусть строка: $s = s_0s_1 ...s_n, s_i ∈ \sum$, где $\sum$ – алфавит.
Полиномиальный хэш

$h(s) = (\sum s_i p^{n - i - 1}) \mod m$, где

$p$ - какое-то число, большее размера алфавита

$m$ – какой-то большой модуль

$s_i$ – ASCII код/номер в алфавите(с единицы)

---
   ![полиномиальный](./line/result/polinomial.png)
---

1. crc32
---
   ![crc32](./line/result/crc32.png)
---

### Результаты тестов

| хэш-функция    | время работы   | 
| ---------------| -------------- | 
| длинна строки  |  0.505500 сек  | 
| сумма букв     |  0.533694 сек  |  
| полиномиальный |  0.544583 сек  |  
| crc32          |  0.533122 сек  |  

### Вывод

Наиболее эффективной хэш-функцией является crc32, она дает наиболее равномерное распределение. Самой неэффективной является длина, так как она она принимает ограниченное кол-тво значений.
